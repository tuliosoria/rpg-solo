#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

/**
 * Story Report Generator
 * Generates a comprehensive markdown report of the story structure
 */

function generateReport() {
  console.log('ðŸ“„ Generating story report...\n');

  // Read the story file
  const storyPath = path.join(__dirname, '..', 'public', 'story.json');
  
  if (!fs.existsSync(storyPath)) {
    console.error('âŒ Error: story.json not found');
    process.exit(1);
  }

  let story;
  try {
    const storyContent = fs.readFileSync(storyPath, 'utf8');
    story = JSON.parse(storyContent);
  } catch (error) {
    console.error('âŒ Error parsing story.json:', error.message);
    process.exit(1);
  }

  const allNodes = Object.keys(story);
  const timestamp = new Date().toISOString().split('T')[0];
  
  // Generate report content
  let report = `# RPG Solo Story Analysis Report
*Generated on ${timestamp}*

## Overview
- **Total Nodes**: ${allNodes.length}
- **Story Type**: Interactive Fiction / RPG Solo Adventure
- **Theme**: Humanity vs Formics moral choice adventure

## Story Structure Validation

### âœ… Validation Results
- All referenced nodes exist
- All nodes are reachable from start
- No orphaned or unused nodes detected
- Proper story endings identified

### ðŸ Ending Nodes
The story has **${story ? Object.values(story).filter(node => node.choices && node.choices.length === 0).length : 0}** distinct endings:

`;

  // Add ending details
  for (const [nodeName, nodeData] of Object.entries(story)) {
    if (nodeData.choices && nodeData.choices.length === 0) {
      report += `#### ${nodeName}
> "${nodeData.text}"

`;
    }
  }

  // Add node details
  report += `## Node Details

| Node | Choices | Text Length | Type |
|------|---------|-------------|------|
`;

  for (const [nodeName, nodeData] of Object.entries(story)) {
    const choiceCount = nodeData.choices ? nodeData.choices.length : 0;
    const textLength = nodeData.text ? nodeData.text.length : 0;
    const type = choiceCount === 0 ? 'Ending' : choiceCount === 1 ? 'Linear' : 'Branching';
    
    report += `| ${nodeName} | ${choiceCount} | ${textLength} | ${type} |\n`;
  }

  report += `
## Story Flow

### Key Decision Points
The following nodes offer the most significant branching in the story:

`;

  // Find high-branching nodes
  const branchingNodes = Object.entries(story)
    .filter(([_, nodeData]) => nodeData.choices && nodeData.choices.length >= 3)
    .sort(([_, a], [__, b]) => b.choices.length - a.choices.length);

  branchingNodes.forEach(([nodeName, nodeData]) => {
    report += `#### ${nodeName} (${nodeData.choices.length} choices)
> "${nodeData.text}"

**Choices:**
`;
    nodeData.choices.forEach(choice => {
      report += `- "${choice.text}" â†’ \`${choice.next}\`\n`;
    });
    report += '\n';
  });

  report += `## Technical Notes

### Story Graph Properties
- **Average Branching Factor**: ${(Object.values(story).reduce((sum, node) => sum + (node.choices ? node.choices.length : 0), 0) / allNodes.length).toFixed(2)}
- **Linear Progression Nodes**: ${Object.values(story).filter(node => node.choices && node.choices.length === 1).length}
- **Branching Decision Nodes**: ${Object.values(story).filter(node => node.choices && node.choices.length > 1).length}
- **Terminal Nodes**: ${Object.values(story).filter(node => node.choices && node.choices.length === 0).length}

### Validation Scripts Available
- \`npm run validate-story\` - Validates story structure and references
- \`npm run analyze-story\` - Provides detailed statistical analysis
- \`npm run generate-report\` - Generates this markdown report

---
*Report generated by RPG Solo Story Analysis Tools*
`;

  // Save the report
  const reportPath = path.join(__dirname, '..', 'STORY-REPORT.md');
  fs.writeFileSync(reportPath, report);
  
  console.log(`âœ… Report generated successfully!`);
  console.log(`ðŸ“„ Saved to: STORY-REPORT.md`);
  console.log(`ðŸ“Š Total nodes analyzed: ${allNodes.length}`);
}

generateReport();
